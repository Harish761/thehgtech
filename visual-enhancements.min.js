(function () { 'use strict'; class AnimatedCounter { constructor(element, options = {}) { this.element = element; this.target = parseInt(element.getAttribute('data-count') || element.textContent.replace(/,/g, '')); this.duration = options.duration || 2000; this.hasAnimated = false; } animate() { if (this.hasAnimated) return; this.hasAnimated = true; const start = 0; const increment = this.target / (this.duration / 16); let current = start; const updateCounter = () => { current += increment; if (current < this.target) { this.element.textContent = Math.floor(current).toLocaleString(); requestAnimationFrame(updateCounter); } else { this.element.textContent = this.target.toLocaleString(); } }; updateCounter(); } } class ScrollAnimations { constructor() { this.elements = []; this.observer = null; this.init(); } init() { const animationClasses = [ '.fade-in', '.slide-in-left', '.slide-in-right', '.scale-in' ]; animationClasses.forEach(className => { document.querySelectorAll(className).forEach(el => { this.elements.push(el); }); }); const options = { threshold: 0.1, rootMargin: '0px 0px -50px 0px' }; this.observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); if (entry.target.hasAttribute('data-count')) { const counter = new AnimatedCounter(entry.target); counter.animate(); } } }); }, options); this.elements.forEach(el => this.observer.observe(el)); } } class ToastManager { constructor() { this.container = null; this.toasts = []; this.init(); } init() { if (!document.querySelector('.toast-container')) { this.container = document.createElement('div'); this.container.className = 'toast-container'; document.body.appendChild(this.container); } else { this.container = document.querySelector('.toast-container'); } } show(message, type = 'info', duration = 3000) { const toast = document.createElement('div'); toast.className = `toast toast-${type}`; const icons = { success: '✓', error: '✕', info: 'ℹ', warning: '⚠' }; toast.innerHTML = ` <div class="toast-icon">${icons[type]}</div> <div class="toast-content"> <div class="toast-message">${message}</div> </div> <button class="toast-close" onclick="this.parentElement.remove()">×</button> `; this.container.appendChild(toast); this.toasts.push(toast); if (duration > 0) { setTimeout(() => { toast.style.animation = 'slideOut 0.3s ease'; setTimeout(() => { if (toast.parentElement) { toast.remove(); } this.toasts = this.toasts.filter(t => t !== toast); }, 300); }, duration); } return toast; } success(message, duration) { return this.show(message, 'success', duration); } error(message, duration) { return this.show(message, 'error', duration); } info(message, duration) { return this.show(message, 'info', duration); } warning(message, duration) { return this.show(message, 'warning', duration); } } function addRippleEffect() { document.querySelectorAll('.ripple').forEach(button => { if (button.hasAttribute('data-ripple-initialized')) return; button.setAttribute('data-ripple-initialized', 'true'); button.addEventListener('click', function (e) { const ripple = document.createElement('span'); const rect = this.getBoundingClientRect(); const size = Math.max(rect.width, rect.height); const x = e.clientX - rect.left - size / 2; const y = e.clientY - rect.top - size / 2; ripple.style.width = ripple.style.height = size + 'px'; ripple.style.left = x + 'px'; ripple.style.top = y + 'px'; ripple.classList.add('ripple-effect'); this.appendChild(ripple); setTimeout(() => ripple.remove(), 600); }); }); } function enhanceExistingElements() { document.querySelectorAll('.section-title').forEach(heading => { if (!heading.classList.contains('gradient-text')) { heading.classList.add('gradient-text'); } }); document.querySelectorAll('.article-card, .stat-card, .vendor-card').forEach(card => { if (!card.classList.contains('hover-lift')) { card.classList.add('hover-lift', 'glass-card'); } }); document.querySelectorAll('[data-animate]').forEach(element => { const animationType = element.getAttribute('data-animate'); if (!element.classList.contains(animationType)) { element.classList.add(animationType); } }); const buttons = document.querySelectorAll('button:not(.tab):not(.tab-btn):not(.threat-vendor-tab), .cta-button, .btn-primary'); buttons.forEach(btn => { if (!btn.classList.contains('ripple')) { btn.classList.add('ripple'); } }); } function enhanceCopyFunctionality() { document.querySelectorAll('[data-copy]').forEach(element => { element.style.cursor = 'pointer'; element.title = 'Click to copy'; element.addEventListener('click', async function () { const textToCopy = this.getAttribute('data-copy') || this.textContent; try { await navigator.clipboard.writeText(textToCopy); window.toast.success('Copied to clipboard!', 2000); } catch (err) { window.toast.error('Failed to copy', 2000); } }); }); } function init() { console.log('[visual-enhancements] Initializing...'); if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); return; } window.toast = new ToastManager(); new ScrollAnimations(); enhanceExistingElements(); addRippleEffect(); enhanceCopyFunctionality(); const observer = new MutationObserver((mutations) => { mutations.forEach((mutation) => { if (mutation.addedNodes.length) { enhanceExistingElements(); addRippleEffect(); enhanceCopyFunctionality(); } }); }); observer.observe(document.body, { childList: true, subtree: true }); console.log('[visual-enhancements] Initialized successfully!'); } init(); window.VisualEnhancements = { toast: () => window.toast, AnimatedCounter: AnimatedCounter, addRipple: addRippleEffect }; })();